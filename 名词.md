###  缓存穿透
缓存中没有该数据，且数据库中也没有该数据。请求直接穿透缓存去访问数据库，浪费了缓存的作用，也给数据库带来额外负担。那么在这种情况下，我们根本没有办法去构建缓存。
### 缓存雪崩：
我们在写入缓存的时候，一般会给这个缓存设置一个过期时间。“缓存雪崩”就像是一个大雪山突然崩塌一样，所有的数据都一下子全都过期了，导致系统的缓存全部消失，系统需要重新从数据库加载所有的数据。这个过程会让系统瞬间承受巨大的压力，可能导致整个系统崩溃，无法继续服务。
**缓存击穿**：
缓存中的热点数据会过期单一key，导致请求直接访问数据库。这个时候，如果很多用户同时请求这些已经失效的热点数据，就会造成数据库的瞬时压力增大，甚至可能导致数据库崩溃，这个现象就叫做“缓存击穿”
#### 幻读
#### 脏读
#### 降级
#### 熔断
#### 限流
#### zookeeper（类nacos）
Zookeeper 是一个开源的**分布式协调服务**，旨在简化分布式系统的复杂性，提供高效、稳定的接口。它通过统一的**命名服务、配置管理、集群管理**等功能，为分布式应用提供一致性服务。

Zookeeper 提供 **统一命名服务**，允许分布式系统生成唯一的命名规则，类似数据库中的主键。通过调用 Zookeeper 的 API（如 _create_ 接口），可以轻松创建目录节点，确保命名的唯一性和可识别性。

#### 聚簇索引
一个表只有一个聚簇索引。将数据和索引存储在一起。其非叶子节点存储索引字段的值，而叶子节点存储整行数据。在InnoDB中，聚簇索引通常基于主键构建，表数据按照主键顺序存储。这种方式确保了物理存储顺序与主键逻辑顺序一致，因此查询效率非常高。

#### 跳表
跳表，即跳跃表（**Skip List**），是基于并联的链表数据结构，操作效率可以达到**O(logN)**，对并发友好。跳表的示意图如下所示。

![跳表的示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0229d967984a74a4307ccda15348af~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=720&h=305&s=72751&e=jpg&b=fefdfd)

跳表的特点，可以概括如下。

- 跳表是多层（**level**）链表结构；
- 跳表中的每一层都是一个有序链表，并且按照元素升序（默认）排列；
- 跳表中的元素会在哪一层出现是随机决定的，但是只要元素出现在了第**k**层，那么**k**层以下的链表也会出现这个元素；
- 跳表的底层的链表包含所有元素；
- 跳表头节点和尾节点不存储元素，且头节点和尾节点的层数就是跳表的最大层数；
- 跳表中的节点包含两个指针，一个指针指向同层链表的后一节点，一个指针指向下层链表的同元素节点。

#### 索引下推
索引下推是 MySQL 在使用二级索引查询时，将原本在 Server 层执行的部分 `WHERE` 条件，下推到存储引擎层，在扫描索引时就提前过滤记录，从而**减少回表次数**的一种优化。
没有 ICP（Index Condition Pushdown 索引下推）
联合索引 `(a, b)`：
`WHERE a = 1 AND b = 2`
- `a` 用于索引定位
- `b` 回表后再过滤
---
 有 ICP
- `a` 用于索引范围定位
- `b` **在索引层直接过滤**
📌 **不违背最左前缀原则**

> 索引下推是 MySQL 在使用二级索引查询时的一种优化手段，它会将原本在 Server 层执行的部分 WHERE 条件，下推到存储引擎层，在扫描索引时就对索引记录进行条件判断，只有满足条件的记录才会回表，从而减少不必要的回表操作和随机 IO。索引下推主要适用于二级索引，常见于联合索引场景，可以在不违反最左前缀原则的前提下提升查询性能。


#### 脏读
一个事务读取到了另一个事务尚未提交的数据。

#### 幻读
同一个事务中，多次按照相同条件查询，返回的记录“行数”发生变化。
#### 不可重复读
同一个事务中，对同一条记录的多次读取，结果不一致。





