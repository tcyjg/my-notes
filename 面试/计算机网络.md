# HTTP协议
HTTP 是超文本传输协议，也就是**H**yper**T**ext **T**ransfer **P**rotocol

## 跨域请求：
http ://服务器:端口/地址， 其中如果协议/服务器（域名）/端口 不一样，就是跨域了。
跨域问题是因为浏览器不允许，服务器还是能够正常处理信息的，浏览器会禁止接收消息。
解决方法，服务端处理跨域请求，响应添加一些响应头access-control-allow-origin，使浏览器允许跨域。
![[Pasted image 20260128102641.png]]

## 请求的安全传递
### 1. 非对称加密
能够保证信息传递的保密性（）
![[Pasted image 20260128102826.png]]
但是非对称加密非常耗时，所以采用非对称加密进行传递对称加密的密钥或者加密参数，实现
### 2. 混合加密
![[Pasted image 20260128103044.png]]
保证保密性

### 3.数字签名
保证传输数据的一致性（确保传输数据能够）
在混合加密的过程中添加了一次不对称加密，计算散列值并使用私钥进行加密，然后接收端使用公钥进行解密，验证接受到的信息散列值是否相同
![[Pasted image 20260128104800.png]]

### 4. 公钥证书（对公钥进行加密）
保证公钥的合法性，防止第三方伪造公钥
解决：认证机构进行数字签名私钥加密，客户端使用认证机构的公钥解密并得到数字签名，数字签名再校验，使用服务器公钥解密后的信息
![[Pasted image 20260128113938.png]]

如果第三方
![[Pasted image 20260128114019.png]]

如果自己伪造证书，浏览器会进行提醒是否信任当前证书。
如果你想去第三方去认证一个证书，
认证机构不会轻易随便颁发证书（会校验你是否是这个域名的所拥有者），

CA 要求你在域名的 DNS 里添加一条 **指定内容的记录**
比如TXT记录：
```txt
_acme-challenge.example.com
TXT "random-string-from-ca"
```
保证你是这个域名的拥有者，才会给你办法证书。

##### 抓包工具为什么能够抓取HTTPS
因为使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。
<mark style="background: #FFB8EBA6;">==污染根CA认证==</mark>
抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

## HTTP 协议的发展
### 一、HTTP/1.1
#### 主要特性
- 使用 TCP
- 默认长连接（Keep-Alive）
- 文本协议
- 支持缓存控制（Cache-Control、ETag）
- 支持分块传输（Chunked Transfer）
#### 主要问题
1. **队头阻塞（HTTP 层）**：同一连接中，请求必须按**顺序**响应
2. **并发能力差**： 浏览器通过“多 TCP 连接”提升并发，本质是权宜之计
3. **头部冗余**“：每个请求重复携带完整 Header
HTTP/1.1 能用，但在高并发、复杂页面场景下效率较低。
### 二、HTTP/2

#### 核心改进
1. **二进制分帧**：报文被拆分为 Frame
2. **多路复用**： 多个 Stream 复用一个 TCP 连接
3. **头部压缩（HPACK）**： 减少重复 Header 传输
4. **服务器推送（可选）**
#### 解决的问题
- 解决了 **HTTP 层队头阻塞**
- 大幅减少 TCP 连接数
- 提高链路利用率
#### 仍然存在的问题
- **TCP 层队头阻塞仍然存在**：TCP 丢包会阻塞所有 Stream
HTTP/2 在 TCP 之上优化了 HTTP，但无法突破 TCP 的机制限制。
### 三、HTTP/3
#### 核心变化
- 使用 **QUIC（基于 UDP）** 作为传输层    
- 内建 TLS 1.3
#### 关键特性
1. **真正的多路复用**: Stream 之间互不阻塞
2. **快速建连**: 1-RTT，支持 0-RTT
3. **连接迁移**:IP 变化不影响连接
#### 解决的问题
- 从传输层消除队头阻塞
- 显著降低连接建立时延
- 提升移动网络场景体验
#### 成本与限制
- 实现复杂，CPU 开销更高
- UDP 在部分网络环境中受限
HTTP/3 通过 QUIC 从根本上解决了性能瓶颈，但部署成本较高。
### 四、HTTP总结
- HTTP/1.1：受限于连接模型和顺序响应
- HTTP/2：在 TCP 上实现多路复用，但仍受 TCP 队头阻塞影响
- HTTP/3：基于 QUIC，重构传输层，




## RPC与HTTP
RPC：（Remote Procedure Call）： **远程过程调用**
1. 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流（可能出现粘包），上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
2. RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去**调用远端**的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。
3. 从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
4. RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
5. **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## WebSocket
# Question
#### 1. 网页中输入网址，整个流程
1. http: 网址 https://www.baidu.com/index.html, 前面http 或者https 是访问数据的协议，www.baidu.com 是服务器，index.html是资源。生成http请求信息，请求行，请求头，请求体
2. DNS：解析域名到真实服务器ip地址。解析流程:  本机缓存表格  --> 顶级域名服务器 -->（ .com，.cn) 区域域名服务器 --> 权威域名服务器  
3. 建立连接：
   建立tcp连接：（SYN：请求  ACK：回复  RST: 重新连接 FIN: 结束连接）
	- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
	- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
	- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
	- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了
		
4. 发送http请求：
	**HTTP 请求**在应用层生成，经 TCP（传输层）、IP（网络层）、以太网（链路层）逐层封装后，最终以以太网帧的形式在链路上传输
5. 服务器处理并返回响应
6. 浏览器解析与渲染
7. 加载子资源
8. 关闭连接


#### 2.TCP中的keepalive和http中的keep - alive 
**http 的keep-alive** ：是进行保证tcp连接之后，不要立刻断开，实现http的长连接，**客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应**，可以减少整体的响应时间。但是**服务器还是按照顺序响应**，先回应 A 请求，完成后再回应 B 请求。而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「**队头阻塞**」的问题。
但是如果http长时间不进行发送请求，岂不是很浪费tcp资源，所以这个keep-alive就是保证tcp连接，多长时间不进行发送请求而断开连接的配置。

tcp的keep-Alive： **TCP 的保活机制**

HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
<mark style="backgroud: #ADCCFFA6;">总结：</mark>
TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。