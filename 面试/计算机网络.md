# HTTP协议
HTTP 是超文本传输协议，也就是**H**yper**T**ext **T**ransfer **P**rotocol

## 跨域请求：
http ://服务器:端口/地址， 其中如果协议/服务器（域名）/端口 不一样，就是跨域了。
跨域问题是因为浏览器不允许，服务器还是能够正常处理信息的，浏览器会禁止接收消息。
解决方法，服务端处理跨域请求，响应添加一些响应头access-control-allow-origin，使浏览器允许跨域。
![[Pasted image 20260128102641.png]]

## 请求的安全传递
### 1. 非对称加密
能够保证信息传递的保密性（）
![[Pasted image 20260128102826.png]]
但是非对称加密非常耗时，所以采用非对称加密进行传递对称加密的密钥或者加密参数，实现
### 2. 混合加密
![[Pasted image 20260128103044.png]]
保证保密性

### 3.数字签名
保证传输数据的一致性（确保传输数据能够）
在混合加密的过程中添加了一次不对称加密，计算散列值并使用私钥进行加密，然后接收端使用公钥进行解密，验证接受到的信息散列值是否相同
![[Pasted image 20260128104800.png]]

### 4. 公钥证书（对公钥进行加密）
保证公钥的合法性，防止第三方伪造公钥
解决：认证机构进行数字签名私钥加密，客户端使用认证机构的公钥解密并得到数字签名，数字签名再校验，使用服务器公钥解密后的信息
![[Pasted image 20260128113938.png]]

如果第三方
![[Pasted image 20260128114019.png]]

如果自己伪造证书，浏览器会进行提醒是否信任当前证书。
如果你想去第三方去认证一个证书，
认证机构不会轻易随便颁发证书（会校验你是否是这个域名的所拥有者），

CA 要求你在域名的 DNS 里添加一条 **指定内容的记录**
比如TXT记录：
```txt
_acme-challenge.example.com
TXT "random-string-from-ca"
```
保证你是这个域名的拥有者，才会给你办法证书。

##### 抓包工具为什么能够抓取HTTPS
因为使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。
<mark style="background: #FFB8EBA6;">==污染根CA认证==</mark>
抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

## HTTP 协议的发展
### 一、HTTP/1.1
#### 主要特性
- 使用 TCP
- 默认长连接（Keep-Alive）
- 文本协议
- 支持缓存控制（Cache-Control、ETag）
- 支持分块传输（Chunked Transfer）
#### 主要问题
1. **队头阻塞（HTTP 层）**：同一连接中，请求必须按**顺序**响应
2. **并发能力差**： 浏览器通过“多 TCP 连接”提升并发，本质是权宜之计
3. **头部冗余**“：每个请求重复携带完整 Header
HTTP/1.1 能用，但在高并发、复杂页面场景下效率较低。
### 二、HTTP/2

#### 核心改进
1. **二进制分帧**：报文被拆分为 Frame
2. **多路复用**： 多个 Stream 复用一个 TCP 连接
3. **头部压缩（HPACK）**： 减少重复 Header 传输
4. **服务器推送（可选）**
#### 解决的问题
- 解决了 **HTTP 层队头阻塞**
- 大幅减少 TCP 连接数
- 提高链路利用率
#### 仍然存在的问题
- **TCP 层队头阻塞仍然存在**：TCP 丢包会阻塞所有 Stream
HTTP/2 在 TCP 之上优化了 HTTP，但无法突破 TCP 的机制限制。
### 三、HTTP/3
#### 核心变化
- 使用 **QUIC（基于 UDP）** 作为传输层    
- 内建 TLS 1.3
#### 关键特性
1. **真正的多路复用**: Stream 之间互不阻塞
2. **快速建连**: 1-RTT，支持 0-RTT
3. **连接迁移**:IP 变化不影响连接
#### 解决的问题
- 从传输层消除队头阻塞
- 显著降低连接建立时延
- 提升移动网络场景体验
#### 成本与限制
- 实现复杂，CPU 开销更高
- UDP 在部分网络环境中受限
HTTP/3 通过 QUIC 从根本上解决了性能瓶颈，但部署成本较高。
### 四、HTTP总结
- HTTP/1.1：受限于连接模型和顺序响应
- HTTP/2：在 TCP 上实现多路复用，但仍受 TCP 队头阻塞影响
- HTTP/3：基于 QUIC，重构传输层，




## RPC与HTTP
RPC：（Remote Procedure Call）： **远程过程调用**
1. 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流（可能出现粘包），上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
2. RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去**调用远端**的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。
3. 从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
4. RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
5. **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## WebSocket 全双工
使用场景：需要**服务端多次放回数据给客户端**的场景:游戏，飞书共同协作，等
- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。

# TCP协议

## 定义
### TCP 头部格式：
![[Pasted image 20260128205011.png]]

**序列号**：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

**控制位：**
- _ACK_：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- _RST_：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- _SYN_：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- _FIN_：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。
### 什么是 TCP
TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议
- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

### 什么是 TCP 连接
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。
Socket ：ip 号+ 端口号
序列号：保证有序性
窗口大小： 做流量控制

### 唯一确定一个 TCP 连接
源地址 + 源端口 + 目的地址 + 目的端口

主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「**端口号**」确定送给哪个应用程序处理。


### TCP 三次握手

#### 三次握手的过程
1. 刚开始都是 close 状态，服务器主动监听某个端口 listen
2. 客户端随机化序号，把 syn 标志成为1 ，该报文不包含任何信息，客户端处于 SYN-SENT 状态
3. 服务段收到报文，也开始初始化自己的序号，其次把确认应答号字段填入 client_isn + 1 把SYN 和 ACK 标志成 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态
4. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
5. 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。
**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**

#### 三次握手的原因：
1. **首要原因是为了防止旧的重复连接初始化造成混乱。** 第三次握手是客户端发起的，所以客户端判断当前连接是否是旧的连接
2. 同步双方初始序列号
#### MTU 和 MSS
![[Pasted image 20260129200539.png]]

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节；
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

网络层中会进行分片，MTU，但是网络层中并不能超时重传，如果ip分片中的某一个分片丢失，**整个 IP 报文的所有分片都得重传**
因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

因此，可以得知由 IP 层进行分片传输，是非常没有效率的。

所以，为了达到最佳的传输效能 TCP 协议在**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。

### TCP 断开连接，四次挥手
客户端发一个 FIN 请求，服务端收到之后进行发 ACK 请求， 在停止发请求之后，发一个 FIN 请求， 最后客户端返回一个 ACK 请求。

**ACK 应答请求不会重发。**
1. 第一次 FIN 请求，表示自己不会再发数据了，但是还可以接受数据. FIN_WAIT_1 状态
2. 服务端发 ACK 表示收到了 FIN 报文后，服务端状态为： `CLOSE_WAIT`  客户端收到这个报文，状态改为：`FIN_WAIT_2`
3. 服务端发 FIN 报文，表示不会再发数据了。服务端进入 `LAST_ACK` 状态客户端接受到 FIN 报文最后返回 ACK 报文。 客户端进入 `TIME_WAIT` 状态
4. 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
5. 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

### TIME_WAIT 等待时间为什么是 2MSL
`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**

### Listen() 和Accept()
`listen()` 并 **不建立 TCP 连接**，它只是：
把 socket 从 **主动 socket** 变成 **监听 socket**
调用 `listen()` 后：
- socket 状态变为 **LISTEN**

内核为该 socket 维护 **两个队列**
 1. 半连接队列（SYN Queue）
	- 到客户端 `SYN`
	- 回复 `SYN+ACK`
	- 等待客户端的 `ACK`
	- 状态：`SYN_RECV`
 2. 全连接队列（Accept Queue）
	- 三次握手完成
	- 状态：`ESTABLISHED`
	- 等待被 `accept()` 取走
 `backlog` 参数：
- 本质上限制的是 **全连接队列大小**

`accept()` 的作用是：
 **从全连接队列中取出一个已建立的 TCP 连接**
 accept 返回一个 **新的 socket（connfd）**
 这个 socket：
    - 只对应 **这一个客户端**
    - 状态是 `ESTABLISHED`
    - 用于 `read / write`
  原来的监听 socket：
	- **仍然只负责监听**
	- 不参与数据收发



## TCP 的可靠性传输
TCP 的**重传机制、滑动窗口、流量控制、拥塞控制**


# Question
#### 1. 网页中输入网址，整个流程
1. http: 网址 https://www.baidu.com/index.html, 前面http 或者https 是访问数据的协议，www.baidu.com 是服务器，index.html是资源。生成http请求信息，请求行，请求头，请求体
2. DNS：解析域名到真实服务器ip地址。解析流程:  本机缓存表格  --> 顶级域名服务器 -->（ .com，.cn) 区域域名服务器 --> 权威域名服务器  
3. 建立连接：
   建立tcp连接：（SYN：请求  ACK：回复  RST: 重新连接 FIN: 结束连接）
	- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
	- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
	- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
	- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了
		
4. 发送http请求：
	**HTTP 请求**在应用层生成，经 TCP（传输层）、IP（网络层）、以太网（链路层）逐层封装后，最终以以太网帧的形式在链路上传输
5. 服务器处理并返回响应
6. 浏览器解析与渲染
7. 加载子资源
8. 关闭连接


#### 2.TCP中的keepalive和http中的keep - alive 
**http 的keep-alive** ：是进行保证tcp连接之后，不要立刻断开，实现http的长连接，**客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应**，可以减少整体的响应时间。但是**服务器还是按照顺序响应**，先回应 A 请求，完成后再回应 B 请求。而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「**队头阻塞**」的问题。
但是如果http长时间不进行发送请求，岂不是很浪费tcp资源，所以这个keep-alive就是保证tcp连接，多长时间不进行发送请求而断开连接的配置。

tcp的keep-Alive： **TCP 的保活机制**

HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
<mark style="backgroud: #ADCCFFA6;">总结：</mark>
TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

### 3. TCP 和 UDP 的区别
_1. 连接_
- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。
_2. 服务对象_
- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信
_3. 可靠性
- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。
_4. 拥塞控制、流量控制_
- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
_5. 首部开销_
- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
_6. 传输方式_
- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
_7. 分段不同_
- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分段，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分段，只需要传输丢失的这个分段。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层（网络层）进行分段，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。如果丢失需要全部重新上传

### 4. TCP 和 UDP 可以同时绑定相同的端口吗？
可以的。
TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。
当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。
因此， TCP/UDP 各自的端口号也相互独立，互不影响。

其中 TCP 连接多个tcp连接，只要四元组（构成） 组合不同，就可以建立，
所以客户端的端口可以重复使用，



### 5. 建立连接时，为什么要随机序列号
主要原因是为了防止历史报文被下一个相同四元组的连接接收。
起始 `ISN` 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时

